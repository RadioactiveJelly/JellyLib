using System;using System.Collections.Generic;using System.Reflection;using System.Reflection.Emit;using Lua;using Lua.Wrapper;using UnityEngine;using HarmonyLib;using MoonSharp.Interpreter;namespace JellyLib.EventExtensions{    [GlobalInstance]    [Include]    [Name("ExtendedGameEvents")]    public class RavenscriptEventExtensions : ScriptEventManager    {        [CallbackSignature(new string[]        {            "projectile"        })]        public ScriptEvent<Projectile, RaycastHit> onProjectileLandOnTerrain { get; protected set; }    }        [HarmonyPatch(typeof(Projectile), "Travel")]    public class PatchProjectileLanding    {        static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)        {            var codeInstructions = new List<CodeInstruction>(instructions);            int insertionIndex = -1;            for (int i = 0; i < codeInstructions.Count - 1; i++) // -1 since we will be checking i + 1            {                var codeInstruction = codeInstructions[i];                if (codeInstruction.opcode == OpCodes.Callvirt && ((MethodInfo)codeInstruction.operand).Name == "SpawnDecal")                {                    insertionIndex = i;                    break;                }            }            var newInstructions = new List<CodeInstruction>();            newInstructions.Add(new CodeInstruction(OpCodes.Call, AccessTools.PropertyGetter(typeof(EventsManagerPatch), nameof(EventsManagerPatch.events))));            newInstructions.Add(new CodeInstruction(OpCodes.Callvirt, AccessTools.PropertyGetter(typeof(RavenscriptEventExtensions), nameof(EventsManagerPatch.events.onProjectileLandOnTerrain))));            newInstructions.Add(new CodeInstruction(OpCodes.Ldarg_0));            newInstructions.Add(new CodeInstruction(OpCodes.Ldloc_1));            newInstructions.Add(new CodeInstruction(OpCodes.Callvirt, AccessTools.Method(typeof(ScriptEvent<Projectile, RaycastHit>), nameof(ScriptEvent<Projectile, RaycastHit>.Invoke),new Type[] { typeof(Projectile), typeof(RaycastHit) })));            if (insertionIndex != -1)            {                codeInstructions.InsertRange(insertionIndex, newInstructions);            }            return codeInstructions;        }    }}