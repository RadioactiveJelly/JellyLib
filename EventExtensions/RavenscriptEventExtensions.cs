using System;using System.Collections.Generic;using System.Reflection;using System.Reflection.Emit;using Lua;using Lua.Wrapper;using UnityEngine;using HarmonyLib;using MoonSharp.Interpreter;namespace JellyLib.EventExtensions{    [GlobalInstance]    [Include]    [Name("ExtendedGameEvents")]    public class RavenscriptEventExtensions : ScriptEventManager    {        [CallbackSignature(new string[]        {            "projectile",            "raycastHit"        })]        public ScriptEvent<Projectile, RaycastHit> onProjectileLandOnTerrain { get; protected set; }                [CallbackSignature(new string[]        {            "sourceActor",            "targetActor"        })]        //Invoked when an actor is healed by a medipack.        public ScriptEvent<Actor, Actor> onMedipackResupply { get;protected set; }    }        [HarmonyPatch(typeof(Projectile), "Travel")]    public class PatchProjectileLanding    {        static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)        {            var codeInstructions = new List<CodeInstruction>(instructions);            int insertionIndex = -1;            for (int i = 0; i < codeInstructions.Count - 1; i++) // -1 since we will be checking i + 1            {                var codeInstruction = codeInstructions[i];                if (codeInstruction.opcode == OpCodes.Callvirt && ((MethodInfo)codeInstruction.operand).Name == "SpawnDecal")                {                    insertionIndex = i;                    break;                }            }            var newInstructions = new List<CodeInstruction>();            newInstructions.Add(new CodeInstruction(OpCodes.Call, AccessTools.PropertyGetter(typeof(EventsManagerPatch), nameof(EventsManagerPatch.events))));            newInstructions.Add(new CodeInstruction(OpCodes.Callvirt, AccessTools.PropertyGetter(typeof(RavenscriptEventExtensions), nameof(EventsManagerPatch.events.onProjectileLandOnTerrain))));            newInstructions.Add(new CodeInstruction(OpCodes.Ldarg_0));            newInstructions.Add(new CodeInstruction(OpCodes.Ldloc_1));            newInstructions.Add(new CodeInstruction(OpCodes.Callvirt, AccessTools.Method(typeof(ScriptEvent<Projectile, RaycastHit>), nameof(ScriptEvent<Projectile, RaycastHit>.Invoke),new Type[] { typeof(Projectile), typeof(RaycastHit) })));            if (insertionIndex != -1)            {                codeInstructions.InsertRange(insertionIndex, newInstructions);            }            return codeInstructions;        }    }        [HarmonyPatch(typeof(Medipack), "Resupply")]    public class PatchMedipack    {        static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)        {            var codeInstructions = new List<CodeInstruction>(instructions);            int insertionIndex = -1;            for (int i = 0; i < codeInstructions.Count - 1; i++) // -1 since we will be checking i + 1            {                var codeInstruction = codeInstructions[i];                if (codeInstruction.opcode == OpCodes.Stfld && ((FieldInfo)codeInstruction.operand).Name == "expireTime")                {                    insertionIndex = i;                    break;                }            }            var newInstructions = new List<CodeInstruction>();            newInstructions.Add(new CodeInstruction(OpCodes.Call, AccessTools.PropertyGetter(typeof(EventsManagerPatch), nameof(EventsManagerPatch.events))));            newInstructions.Add(new CodeInstruction(OpCodes.Callvirt, AccessTools.PropertyGetter(typeof(RavenscriptEventExtensions), nameof(EventsManagerPatch.events.onMedipackResupply))));            newInstructions.Add(new CodeInstruction(OpCodes.Ldarg_0));            newInstructions.Add(new CodeInstruction(OpCodes.Ldfld, AccessTools.Field(typeof(Projectile), nameof(Projectile.killCredit))));            newInstructions.Add(new CodeInstruction(OpCodes.Ldloca_S, (byte)0));            newInstructions.Add(new CodeInstruction(OpCodes.Call, AccessTools.PropertyGetter(typeof(List<Actor>.Enumerator), nameof(List<Actor>.Enumerator.Current))));            newInstructions.Add(new CodeInstruction(OpCodes.Callvirt, AccessTools.Method(typeof(ScriptEvent<Actor, Actor>), nameof(ScriptEvent<Actor, Actor>.Invoke),new Type[] { typeof(Actor), typeof(Actor) })));            if (insertionIndex != -1)            {                codeInstructions.InsertRange(insertionIndex, newInstructions);            }            return codeInstructions;        }    }}